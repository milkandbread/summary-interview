1 Boyer-Mooreç®—æ³•,æ¯”kmpç®—æ³•è¦å¿«3-5å€
https://blog.csdn.net/appleprince88/article/details/11881323

2 å†’æ³¡æ’åºæ”¹è¿›ï¼š

åŸç†ï¼šæ–¼æ°£æ³¡æ’åºçš„é›™å‘é€²è¡Œï¼Œå…ˆè®“æ°£æ³¡æ’åºç”±å·¦å‘å³é€²è¡Œï¼Œå†ä¾†è®“æ°£æ³¡æ’åºç”±å³å¾€å·¦é€²è¡Œï¼Œå¦‚æ­¤å®Œæˆä¸€æ¬¡æ’åºçš„å‹•ä½œï¼Œè€Œæ‚¨å¿…é ˆä½¿ç”¨leftèˆ‡rightå…©å€‹æ——æ¨™ä¾†è¨˜éŒ„å·¦å³å…©ç«¯å·²æ’åºçš„å…ƒç´ ä½ç½®ã€‚

ä¸€å€‹æ’åºçš„ä¾‹å­å¦‚ä¸‹æ‰€ç¤ºï¼š

æ’åºå‰ï¼š45 19 77 81 13 28 18 19 77 11

å¾€å³æ’åºï¼š19 45 77 13 28 18 19 77 11 [81]
å‘å·¦æ’åºï¼š[11] 19 45 77 13 28 18 19 77 [81]

å¾€å³æ’åºï¼š[11] 19 45 13 28 18 19 [77 77 81]
å‘å·¦æ’åºï¼š[11 13] 19 45 18 28 19 [77 77 81]

å¾€å³æ’åºï¼š[11 13] 19 18 28 19 [45 77 77 81]
å‘å·¦æ’åºï¼š[11 13 18] 19 19 28 [45 77 77 81]

å¾€å³æ’åºï¼š[11 13 18] 19 19 [28 45 77 77 81]
å‘å·¦æ’åºï¼š[11 13 18 19 19] [28 45 77 77 81]

å¦‚ä¸Šæ‰€ç¤ºï¼Œæ‹¬è™Ÿä¸­è¡¨ç¤ºå·¦å³å…©é‚Šå·²æ’åºå®Œæˆçš„éƒ¨ä»½ï¼Œç•¶left > rightæ™‚ï¼Œå‰‡æ’åºå®Œæˆã€‚

ä»£ç ï¼š

void shakersort(int number[]) { 
    int i, left = 0, right = MAX - 1, shift = 0; 

    while(left < right) { 
        // å‘å³é€²è¡Œæ°£æ³¡æ’åº 
        for(i = left; i < right; i++) { 
            if(number[i] > number[i+1]) { 
                SWAP(number[i], number[i+1]); 
                shift = i; 
            } 
        } 
        right = shift; 

        printf("\nå¾€å³æ’åºï¼š"); 
        for(i = 0; i < MAX; i++) 
            printf("%d ", number[i]); 

        // å‘å·¦é€²è¡Œæ°£æ³¡æ’åº 
        for(i = right; i > left; i--) { 
            if(number[i] < number[i-1]) { 
                SWAP(number[i], number[i-1]); 
                shift = i; 
            } 
        } 
        left = shift; 

        printf("\nå‘å·¦æ’åºï¼š"); 
        for(i = 0; i < MAX; i++) 
            printf("%d ", number[i]); 
    } 
} 


å †æ’åº
å †(HEAP)å¿…é¡»è¦æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼ŒåŒæ—¶æ»¡è¶³çˆ¶èŠ‚ç‚¹çš„å†…å®¹å¤§äº(æˆ–å°äº)å­èŠ‚ç‚¹ã€‚
å †çš„åº•å±‚æ•°æ®ç»“æ„ä¸ºä¸€ç»´æ•°ç»„ï¼Œæ­¤æ—¶è‹¥å½“å‰èŠ‚ç‚¹ä¸ºğ‘–ï¼Œåˆ™å…¶çˆ¶å­èŠ‚ç‚¹ç´¢å¼•å¯ç›´æ¥é€šè¿‡ä»¥ä¸‹å…¬å¼ç›´æ¥è®¡ç®—å¾—åˆ°ã€‚



1 è®¾è®¡ä¸€ä¸ªæ”¯æŒ pushï¼Œpopï¼Œtop æ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚

    push(x) -- å°†å…ƒç´  x æ¨å…¥æ ˆä¸­ã€‚
    pop() -- åˆ é™¤æ ˆé¡¶çš„å…ƒç´ ã€‚
    top() -- è·å–æ ˆé¡¶å…ƒç´ ã€‚
    getMin() -- æ£€ç´¢æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚

class MinStack {
public:
    stack<int> s;//æ•°æ®æ ˆ
    stack<int> min;//è¾…åŠ©æ ˆ
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        s.push(x);
        if(min.empty()||x<=min.top())
        {
            min.push(x);
        }
    }
    
    void pop() {
        if(s.top()==min.top())
            min.pop();
        s.pop();
    }
    
    int top() {
        return s.top();
    }
    int getMin() {
        return min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */

 2 ä½¿ç”¨é˜Ÿåˆ—å®ç°æ ˆçš„ä¸‹åˆ—æ“ä½œï¼š

    push(x) -- å…ƒç´  x å…¥æ ˆ
    pop() -- ç§»é™¤æ ˆé¡¶å…ƒç´ 
    top() -- è·å–æ ˆé¡¶å…ƒç´ 
    empty() -- è¿”å›æ ˆæ˜¯å¦ä¸ºç©º

class MyStack {
    queue<int> que;
public:
    /** Initialize your data structure here. */
    /** Initialize your data structure here. */
    MyStack() {
        
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        queue<int> temp;
        int t=0;
        int length=que.size();
        for(int i=0; i<length; i++)
        {
            t=que.front();
            que.pop();
            temp.push(t);
        }
        //     temp.push(que.pop());
        que.push(x);
        // cout<<x<<" ";
        for(int i=0; i<length; i++)
        {
            t=temp.front();
            que.push(t);
            temp.pop();
           // cout<<t<<" ";
        }
        //cout<<endl;
        //     que.push(temp.pop());
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        if(que.empty())
            return 0;
        int t=que.front();
        que.pop();
        return t;
    }
    
    /** Get the top element. */
    int top() {
        if(que.empty())
            return 0;
        return que.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */

 ä½¿ç”¨æ ˆå®ç°é˜Ÿåˆ—çš„ä¸‹åˆ—æ“ä½œï¼š

    push(x) -- å°†ä¸€ä¸ªå…ƒç´ æ”¾å…¥é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚
    pop() -- ä»é˜Ÿåˆ—é¦–éƒ¨ç§»é™¤å…ƒç´ ã€‚
    peek() -- è¿”å›é˜Ÿåˆ—é¦–éƒ¨çš„å…ƒç´ ã€‚
    empty() -- è¿”å›é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚

ç¤ºä¾‹:

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // è¿”å› 1
queue.pop();   // è¿”å› 1
queue.empty(); // è¿”å› false

class MyQueue {
    stack<int> st;
public:
    /** Initialize your data structure here. */
    MyQueue() {
        
    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stack<int> tmp;
        int i=0,t=0;
        for(i=0;i<st.size();i++)
        {
            t = st.top();
            st.pop();
            tmp.push(t);
        }
        st.push(x);
        for(i=0;i<tmp.size();i++)
        {
            t = tmp.top();
            tmp.pop();
            st.push(t);
        }
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        stack<int> tmp;
        int i=0,t=0;
        for(i=0;i<st.size();i++)
        {
            t = st.top();
            st.pop();
            tmp.push(t);
        }
        
        for(i=0;i<tmp.size()-1;i++)
        {
            t = tmp.top();
            tmp.pop();
            st.push(t);
        }
        
        return t;
    }
    
    /** Get the front element. */
    int peek() {
        int i=0,t =0;
        for(i=0;i<st.size();i++)
        {
            t = st.top();
        }
        return t;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        if(st.empty())
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */


ä½ ç°åœ¨æ˜¯æ£’çƒæ¯”èµ›è®°å½•å‘˜ã€‚
ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²å¯ä»¥æ˜¯ä»¥ä¸‹å››ç§ç±»å‹ä¹‹ä¸€ï¼š
1.æ•´æ•°ï¼ˆä¸€è½®çš„å¾—åˆ†ï¼‰ï¼šç›´æ¥è¡¨ç¤ºæ‚¨åœ¨æœ¬è½®ä¸­è·å¾—çš„ç§¯åˆ†æ•°ã€‚
2. "+"ï¼ˆä¸€è½®çš„å¾—åˆ†ï¼‰ï¼šè¡¨ç¤ºæœ¬è½®è·å¾—çš„å¾—åˆ†æ˜¯å‰ä¸¤è½®æœ‰æ•ˆ å›åˆå¾—åˆ†çš„æ€»å’Œã€‚
3. "D"ï¼ˆä¸€è½®çš„å¾—åˆ†ï¼‰ï¼šè¡¨ç¤ºæœ¬è½®è·å¾—çš„å¾—åˆ†æ˜¯å‰ä¸€è½®æœ‰æ•ˆ å›åˆå¾—åˆ†çš„ä¸¤å€ã€‚
4. "C"ï¼ˆä¸€ä¸ªæ“ä½œï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå›åˆçš„åˆ†æ•°ï¼‰ï¼šè¡¨ç¤ºæ‚¨è·å¾—çš„æœ€åä¸€ä¸ªæœ‰æ•ˆ å›åˆçš„åˆ†æ•°æ˜¯æ— æ•ˆçš„ï¼Œåº”è¯¥è¢«ç§»é™¤ã€‚

class Solution {
public:
    int calPoints(vector<string>& ops) {
        int sum=0;
        vector<int>v;
        int j=0;
        for(int i=0;i<ops.size();i++){
            string s=ops[i];
            if(s=="C"){  //æ³¨æ„è¿™é‡Œç”¨" "  å› ä¸ºå‘é‡ä¸ºå­—ç¬¦ä¸²ç±»å‹
                sum-=v[j-1];
                v.pop_back();
                j--;
 
            }
            else if(s=="D"){
                sum+=2*v[j-1];
                v.push_back(2*v[j-1]);
                j++;
            }
            else if(s=="+"){
                sum+=v[j-1]+v[j-2];
                v.push_back(v[j-1]+v[j-2]);
                j++;
            }
            else{
                sum+=stoi(s);  //C++ 11æ ‡å‡†ç‰¹æ€§ï¼Œç›´æ¥å°†å­—ç¬¦è½¬æ¢æˆæ•´æ•°.
                v.push_back(stoi(s));
                j++;
            }
        
           
        }
         return sum;
    }
};



ç»™å®š S å’Œ T ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå½“å®ƒä»¬åˆ†åˆ«è¢«è¾“å…¥åˆ°ç©ºç™½çš„æ–‡æœ¬ç¼–è¾‘å™¨åï¼Œåˆ¤æ–­äºŒè€…æ˜¯å¦ç›¸ç­‰ï¼Œå¹¶è¿”å›ç»“æœã€‚ # ä»£è¡¨é€€æ ¼å­—ç¬¦ã€‚

 

ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šS = "ab#c", T = "ad#c"
è¾“å‡ºï¼štrue
è§£é‡Šï¼šS å’Œ T éƒ½ä¼šå˜æˆ â€œacâ€ã€‚

bool backspaceCompare(string S, string T)
{
    int len1 = S.size();
    int len2 = T.size();
    string s1, t1;
    stack<char> stk;
    for (int i = 0;i < len1;i++)
    {
        if (S[i] != '#')
        {
            stk.push(S[i]);
        }
        else
        {
            if (!stk.empty())
            {
                stk.pop();
            }
        }
    }
    while (!stk.empty())
    {
        s1 += stk.top();
        stk.pop();
    }
    for (int i = 0;i < len2;i++)
    {
        if (T[i] != '#')
        {
            stk.push(T[i]);
        }
        else
        {
            if (!stk.empty())
            {
                stk.pop();
            }
        }
    }
    while (!stk.empty())
    {
        t1 += stk.top();
        stk.pop();
    }
    return s1 == t1 ? true : false;
}



å¦‚æœæœ‰æ•ˆå­—ç¬¦ä¸² S éç©ºï¼Œä¸”ä¸å­˜åœ¨å°†å…¶æ‹†åˆ†ä¸º S = A+B çš„æ–¹æ³•ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºåŸè¯­ï¼ˆprimitiveï¼‰ï¼Œå…¶ä¸­ A å’Œ B éƒ½æ˜¯éç©ºæœ‰æ•ˆæ‹¬å·å­—ç¬¦ä¸²ã€‚


ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼š"(()())(())"
è¾“å‡ºï¼š"()()()"
è§£é‡Šï¼š
è¾“å…¥å­—ç¬¦ä¸²ä¸º "(()())(())"ï¼ŒåŸè¯­åŒ–åˆ†è§£å¾—åˆ° "(()())" + "(())"ï¼Œ
åˆ é™¤æ¯ä¸ªéƒ¨åˆ†ä¸­çš„æœ€å¤–å±‚æ‹¬å·åå¾—åˆ° "()()" + "()" = "()()()"ã€‚

class Solution {
public:
    string removeOuterParentheses(string S) {
        int flag = 0;
        int len = S.length();
        string ret;
        int i =0;
        
        for(i=0;i<len;i++)
        {
            if(S[i] == '(' )
            {
                if (flag > 0)
                {
                    ret += S[i];
                }
                flag++;
            }
            else if( S[i] == ')')
            {
                flag--;
                if( flag > 0)
                {
                    ret += S[i];
                }
            }
        }
        
        return ret;
    }
};


ç»™å‡ºç”±å°å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² Sï¼Œé‡å¤é¡¹åˆ é™¤æ“ä½œä¼šé€‰æ‹©ä¸¤ä¸ªç›¸é‚»ä¸”ç›¸åŒçš„å­—æ¯ï¼Œå¹¶åˆ é™¤å®ƒä»¬
ç¤ºä¾‹ï¼š

è¾“å…¥ï¼š"abbaca"
è¾“å‡ºï¼š"ca"
è§£é‡Šï¼š
ä¾‹å¦‚ï¼Œåœ¨ "abbaca" ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ é™¤ "bb" ç”±äºä¸¤å­—æ¯ç›¸é‚»ä¸”ç›¸åŒï¼Œè¿™æ˜¯æ­¤æ—¶å”¯ä¸€å¯ä»¥æ‰§è¡Œåˆ é™¤æ“ä½œçš„é‡å¤é¡¹ã€‚ä¹‹åæˆ‘ä»¬å¾—åˆ°å­—ç¬¦ä¸² "aaca"ï¼Œå…¶ä¸­åˆåªæœ‰ "aa" å¯ä»¥æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œæ‰€ä»¥æœ€åçš„å­—ç¬¦ä¸²ä¸º "ca"ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution {
public:
    string removeDuplicates(string S) {
        vector<char> vec;
        int len = S.length();
        int i=0, j=0;
        string ret;
        
        for(i=0;i<len;i++)
        {
            if(!vec.empty() ) 
            {
                if (S[i] == vec[j-1])
                {
                vec.pop_back();
                j--;
                }
            }
            else
            {
                vec.push_back(S[i]);
                j++;
            }
        }
        
        for(i=0;i<vec.size();i++)
        {
            ret += vec[i];
        }
        return ret;
    }
};

-----------------------------------------------
åœ¨ Unix é£æ ¼çš„æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªç‚¹ï¼ˆ.ï¼‰è¡¨ç¤ºå½“å‰ç›®å½•æœ¬èº«ï¼›æ­¤å¤–ï¼Œä¸¤ä¸ªç‚¹ ï¼ˆ..ï¼‰ è¡¨ç¤ºå°†ç›®å½•åˆ‡æ¢åˆ°ä¸Šä¸€çº§ï¼ˆæŒ‡å‘çˆ¶ç›®å½•ï¼‰ï¼›ä¸¤è€…éƒ½å¯ä»¥æ˜¯å¤æ‚ç›¸å¯¹è·¯å¾„çš„ç»„æˆéƒ¨åˆ†.
ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼š"/home/"
è¾“å‡ºï¼š"/home"
è§£é‡Šï¼šæ³¨æ„ï¼Œæœ€åä¸€ä¸ªç›®å½•ååé¢æ²¡æœ‰æ–œæ ã€‚

ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼š"/../"
è¾“å‡ºï¼š"/"
è§£é‡Šï¼šä»æ ¹ç›®å½•å‘ä¸Šä¸€çº§æ˜¯ä¸å¯è¡Œçš„ï¼Œå› ä¸ºæ ¹æ˜¯ä½ å¯ä»¥åˆ°è¾¾çš„æœ€é«˜çº§ã€‚

ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼š"/home//foo/"
è¾“å‡ºï¼š"/home/foo"
è§£é‡Šï¼šåœ¨è§„èŒƒè·¯å¾„ä¸­ï¼Œå¤šä¸ªè¿ç»­æ–œæ éœ€è¦ç”¨ä¸€ä¸ªæ–œæ æ›¿æ¢ã€‚

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/simplify-path
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

class Solution {
public:
    string simplifyPath(string path) {
        stack<string> st;
        string str;
        string ret;
        int i=0;
        
        for(i=0;i<path.length();i++)
        {
            if(path[i] != '/')
            {
                str += path[i];
            }
            
            if(str.length()>0 && path[i] == '/')
            {
                if(str==".." && !st.empty())
                {
                    st.pop();
                }
                else 
                {
                    st.push(str);
                }
                str="";
            }
        }
        for(i=0;i<st.size();i++)
        {
            ret += "/";
            ret += st.top();
            st.pop();
        }
        return ret;
    }
};


ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚æ¬¡éå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚

ä¾‹å¦‚ï¼š
ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

è¿”å›é”¯é½¿å½¢å±‚æ¬¡éå†å¦‚ä¸‹ï¼š

[
  [3],
  [20,9],
  [15,7]
]

class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector< vector<int>> vec;
        queue<TreeNode *> first;
        queue<TreeNode *> second;
        TreeNode *tmp_tree;
        first.push(root);
        
        while(!first.empty())
        {
            vector<int> sub_vect;
            while(!first.empty())
            {
                tmp_tree = first.front();
                first.pop();
                sub_vect.push_back(tmp_tree->val);
                if(tmp_tree->left)
                {
                    second.push(tmp_tree->left);
                }
                if(tmp_tree->right)
                {
                    second.push(tmp_tree->right);
                }
            }
            vec.push_back(sub_vect);
            first.swap(second);
        }
        return vec;
    }
};



ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ å‰åº éå†ã€‚

 ç¤ºä¾‹:

è¾“å…¥: [1,null,2,3]  
   1
    \
     2
    /
   3 

è¾“å‡º: [1,2,3]

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        TreeNode *tmp_tree = root;
        vector<int> vec;
        
        while(tmp_tree || !st.empty())
        {
            while(tmp_tree)
            {
                vec.push_back(tmp_tree->val);
                st.push(tmp_tree);
                tmp_tree = tmp_tree->left;
            }
            if(!st.empty())
            {
                tmp_tree = st.top();
                st.pop();
                tmp_tree=tmp_tree->right;
            }
        }
        
        return vec;
    }
};


æœ‰æ•ˆçš„è¿ç®—ç¬¦åŒ…æ‹¬ +, -, *, / ã€‚æ¯ä¸ªè¿ç®—å¯¹è±¡å¯ä»¥æ˜¯æ•´æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯å¦ä¸€ä¸ªé€†æ³¢å…°è¡¨è¾¾å¼ã€‚
ç¤ºä¾‹ 1ï¼š

è¾“å…¥: ["2", "1", "+", "3", "*"]
è¾“å‡º: 9
è§£é‡Š: ((2 + 1) * 3) = 9


class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int i=0,j=0;
        int ret=0;
        stack<int> vec;
        int sum=0;
        
        for(i=0;i<tokens.size();i++)
        {
            if(vec.size()>1 && tokens[i] == "+")
            {
                int first = vec.top();
                vec.pop();
                int second = vec.top();
                vec.pop();
                sum = first+second;
                vec.push(sum);
            }
            else if(vec.size()>1 && tokens[i] == "-")
            {
                int first = vec.top();
                vec.pop();
                int second = vec.top();
                vec.pop();
                sum = first-second;
                vec.push(sum);
            }
            else if(vec.size()>1 && tokens[i] == "/")
            {
                int first = vec.top();
                vec.pop();
                int second = vec.top();
                vec.pop();
                sum = first/second;
                vec.push(sum);
            }
            else if(vec.size()>1 && tokens[i] == "*")
            {
                int first = vec.top();
                vec.pop();
                int second = vec.top();
                vec.pop();
                sum = first*second;
                vec.push(sum);
            }
            else
            {
                vec.push(stoi(tokens[i]));
                j++;
            }
        }
        if(vec.size() == 1)
        {
            sum = vec.top();
            vec.pop();
        }
        
        return sum;
    }
};



å®ç°ä¸€ä¸ªäºŒå‰æœç´¢æ ‘è¿­ä»£å™¨ã€‚ä½ å°†ä½¿ç”¨äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹åˆå§‹åŒ–è¿­ä»£å™¨ã€‚

è°ƒç”¨ next() å°†è¿”å›äºŒå‰æœç´¢æ ‘ä¸­çš„ä¸‹ä¸€ä¸ªæœ€å°çš„æ•°ã€‚

 

ç¤ºä¾‹ï¼š

BSTIterator iterator = new BSTIterator(root);
iterator.next();    // è¿”å› 3
iterator.next();    // è¿”å› 7
iterator.hasNext(); // è¿”å› true
iterator.next();    // è¿”å› 9
iterator.hasNext(); // è¿”å› true
iterator.next();    // è¿”å› 15
iterator.hasNext(); // è¿”å› true
iterator.next();    // è¿”å› 20
iterator.hasNext(); // è¿”å› false


class BSTIterator {
public:
    BSTIterator(TreeNode *root) {
        if(root) createStack(root);
    }
    void createStack(TreeNode *root) {
        if (root->right) createStack(root->right);
        if (root) s.push(root->val);
        if (root->left) createStack(root->left);
    }
    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !s.empty();
    }
 
    /** @return the next smallest number */
    int next() {
        int tmp = s.top();
        s.pop();
        return tmp;
    }
private:
    stack<int> s;
};



ç»™å®šä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¾“å‡ºæ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ã€‚æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ æ˜¯æŒ‰æ•°ç»„éå†é¡ºåºï¼Œè¿™ä¸ªæ•°å­—ä¹‹åçš„ç¬¬ä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„æ•°ï¼Œè¿™æ„å‘³ç€ä½ åº”è¯¥å¾ªç¯åœ°æœç´¢å®ƒçš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º -1ã€‚

ç¤ºä¾‹ 1:

è¾“å…¥: [1,2,1]
è¾“å‡º: [2,-1,2]
è§£é‡Š: ç¬¬ä¸€ä¸ª 1 çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯ 2ï¼›
æ•°å­— 2 æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ï¼› 
ç¬¬äºŒä¸ª 1 çš„ä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°éœ€è¦å¾ªç¯æœç´¢ï¼Œç»“æœä¹Ÿæ˜¯ 2ã€‚

class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
      int n = nums.size();
        vector<int> res(n); // å­˜æ”¾ç»“æœ
        stack<int> s;
        // å‡è£…è¿™ä¸ªæ•°ç»„é•¿åº¦ç¿»å€äº†
        for (int i = 2 * n - 1; i >= 0; i--) {
            while (!s.empty() && s.top() <= nums[i % n])
                s.pop();
            res[i % n] = s.empty() ? -1 : s.top();
            s.push(nums[i % n]);
        }
        return res;
    }
};
